<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>HANU Feed Dashboard</title>
  <link href="shared/common.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/twemoji@14.0.2/dist/twemoji.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
</head>
<body>
  <div class="container">
    <!-- Navigation -->
    <div class="nav">
      <a href="index.html">ğŸ  Home</a>
      <a href="dashboard.html" class="active">ğŸ¤– Dashboard</a>
      <a href="prompt-editor.html">âœï¸ Prompt Editor</a>
      <a href="stats.html">ğŸ“Š Statistics</a>
    </div>

    <!-- Header -->
    <div class="header">
      <h1>ğŸ¤– Feed Management Dashboard</h1>
      <p>Manage RSS feeds and Discord channel mappings for HANU University</p>
    </div>

    <!-- Authentication -->
    <div class="auth-section" id="auth-section">
      <h3>ğŸ” Authentication Required</h3>
      <input type="password" id="auth-token" placeholder="Enter AUTH_TOKEN">
      <button id="login-button">Login</button>
      <div id="auth-status" style="margin-top: 10px;"></div>
    </div>

    <!-- Main Content -->
    <div id="main-content" class="hidden">
      <!-- System Status -->
      <div class="status-grid">
        <div class="status-card">
          <strong>ğŸ¤– Bot Status</strong>
          <div class="status-value" id="bot-status">Loading...</div>
        </div>
        <div class="status-card">
          <strong>ğŸ“¡ Active Feeds</strong>
          <div class="status-value" id="feed-count">0</div>
        </div>
        <div class="status-card">
          <strong>ğŸ“¨ Processed Posts</strong>
          <div class="status-value" id="seen-count">0</div>
        </div>
      </div>

      <!-- Quick Add Forms -->
      <div class="form-row">
        <div class="form-group">
          <input type="text" id="new-feed-url" placeholder="RSS feed URL">
          <button onclick="addFeed()" class="btn btn-primary">â• Add Feed</button>
        </div>
        <div class="form-group">
          <input type="text" id="new-group-name" placeholder="Group name">
          <button onclick="addGroup()" class="btn btn-secondary">ğŸ“ Add Group</button>
        </div>
      </div>

      <!-- View Controls -->
      <div class="controls">
        <label>View:</label>
        <div class="btn-group">
          <button class="btn btn-outline active" onclick="setView('flat')" id="view-flat">ğŸ“„ Flat</button>
          <button class="btn btn-outline" onclick="setView('grouped')" id="view-grouped">ğŸ“ Grouped</button>
        </div>

        <label>Sort:</label>
        <div class="btn-group">
          <button class="btn btn-outline active" onclick="setSort('name')" id="sort-name">Name</button>
          <button class="btn btn-outline" onclick="setSort('date')" id="sort-date">Date</button>
          <button class="btn btn-outline" onclick="setSort('channel')" id="sort-channel">Channel</button>
          <button class="btn btn-outline" onclick="setSort('group')" id="sort-group">Group</button>
        </div>

        <label>Filter:</label>
        <div class="btn-group">
          <button class="btn btn-outline active" onclick="setFilter('all')" id="filter-all">All</button>
          <button class="btn btn-outline" onclick="setFilter('active')" id="filter-active">Active</button>
          <button class="btn btn-outline" onclick="setFilter('inactive')" id="filter-inactive">Inactive</button>
        </div>
      </div>

      <!-- Feeds Section -->
      <div class="section">
        <h2>ğŸ“‹ RSS Feeds</h2>
        <div id="feeds-container">
          <div class="loading">Loading feeds...</div>
        </div>
      </div>

      <!-- Channels Section -->
      <div class="section">
        <h2>ğŸ’¬ Discord Channels</h2>
        <div class="form-group mb-15">
          <input type="text" id="new-channel-id" placeholder="Discord Channel ID">
          <input type="text" id="new-channel-name" placeholder="Channel Name (optional)">
          <select id="new-channel-type">
            <option value="text">Text Channel</option>
            <option value="forum">Forum Channel</option>
            <option value="voice">Voice Channel</option>
          </select>
          <button onclick="addChannel()" class="btn btn-primary">â• Add Channel</button>
        </div>
        
        <div id="channels-list">
          <div class="loading">Loading channels...</div>
        </div>
      </div>

      <!-- Bot Controls -->
      <div class="section">
        <h2>ğŸ® Bot Controls</h2>
        <div class="flex gap-15">
          <button onclick="runBot()" class="btn btn-success" id="run-bot-btn">ğŸš€ Run Bot Now</button>
          <button onclick="clearCache()" class="btn btn-secondary">ğŸ—‘ï¸ Clear Cache</button>
          <button onclick="refreshData()" class="btn btn-secondary">ğŸ”„ Refresh Data</button>
          <button onclick="exportData()" class="btn btn-outline">ğŸ“¥ Export Data</button>
        </div>
        
        <div id="job-output" class="code-output hidden mt-15"></div>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script type="module">
    import HanuAuth from './shared/auth.js';
    import HanuAPI from './shared/api.js';

    // Dashboard state
    let feeds = [];
    let channels = [];
    let groups = {};
    let feedMappings = {};
    let currentView = 'flat';
    let currentSort = 'name';
    let currentFilter = 'all';
    let feedMetadata = {};

    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
      // Setup authentication UI
      HanuAuth.setupAuthUI();
      
      // Setup authentication callback
      HanuAuth.onLogin(async () => {
        await loadAllData();
      });
      
      // Parse emojis
      twemoji.parse(document.body, { folder: 'svg', ext: '.svg' });
      
      // Auto-load if already authenticated
      if (HanuAuth.isAuthenticated()) {
        const isValid = await HanuAuth.testAuth();
        if (isValid) {
          document.getElementById('auth-section').classList.add('hidden');
          document.getElementById('main-content').classList.remove('hidden');
          await loadAllData();
        }
      }
    });

    // Load all dashboard data
    async function loadAllData() {
      try {
        const [feedsData, channelsData, statusData] = await Promise.all([
          HanuAPI.getFeeds(),
          HanuAPI.getChannels(),
          HanuAPI.getSystemStatus()
        ]);

        feeds = feedsData.feeds || [];
        channels = channelsData.channels || [];
        groups = feedsData.groups || {};
        feedMappings = feedsData.mappings || {};
        feedMetadata = feedsData.metadata || {};

        updateStatusCards(statusData);
        renderFeeds();
        renderChannels();

      } catch (error) {
        console.error('Failed to load dashboard data:', error);
        showAlert('Failed to load data: ' + error.message, 'danger');
      }
    }

    // Update status cards
    function updateStatusCards(statusData) {
      document.getElementById('bot-status').textContent = statusData.workerStatus || 'Unknown';
      document.getElementById('feed-count').textContent = feeds.length;
      document.getElementById('seen-count').textContent = statusData.seenCount || 0;
    }

    // Render feeds based on current view/sort/filter
    function renderFeeds() {
      const container = document.getElementById('feeds-container');
      
      if (feeds.length === 0) {
        container.innerHTML = '<div class="loading">No feeds configured</div>';
        return;
      }

      // Apply filters
      let filteredFeeds = feeds.filter(feed => {
        if (currentFilter === 'all') return true;
        if (currentFilter === 'active') return isActiveFeed(feed);
        if (currentFilter === 'inactive') return !isActiveFeed(feed);
        return true;
      });

      // Apply sorting
      filteredFeeds.sort((a, b) => {
        switch (currentSort) {
          case 'name':
            return (getTitle(a) || '').localeCompare(getTitle(b) || '');
          case 'date':
            return new Date(getLastPost(b) || 0) - new Date(getLastPost(a) || 0);
          case 'channel':
            return getChannelName(a).localeCompare(getChannelName(b));
          case 'group':
            return (getGroup(a) || '').localeCompare(getGroup(b) || '');
          default:
            return 0;
        }
      });

      if (currentView === 'grouped') {
        renderGroupedFeeds(filteredFeeds);
      } else {
        renderFlatFeeds(filteredFeeds);
      }
      
      twemoji.parse(container, { folder: 'svg', ext: '.svg' });
    }

    // Render flat feed list
    function renderFlatFeeds(feedList) {
      const container = document.getElementById('feeds-container');
      
      let html = `
        <table class="feeds-table">
          <thead>
            <tr>
              <th>ğŸ“‹ Name</th>
              <th>ğŸ“… Last Post</th>
              <th>ğŸ’¬ Channel</th>
              <th>ğŸ“ Group</th>
              <th>ğŸ”— Link</th>
              <th>âš™ï¸ Actions</th>
            </tr>
          </thead>
          <tbody>
      `;

      feedList.forEach(feed => {
        const title = getTitle(feed);
        const lastPost = formatDate(getLastPost(feed));
        const channelName = getChannelName(feed);
        const groupName = getGroup(feed) || 'None';
        const pageUrl = getPageUrl(feed);
        const isActive = isActiveFeed(feed);

        html += `
          <tr class="${isActive ? '' : 'text-muted'}">
            <td>
              <div class="feed-title">${title}</div>
              <small class="text-muted">${feed.url.substring(0, 60)}...</small>
            </td>
            <td>
              <span class="badge ${isActive ? 'bg-success' : 'bg-secondary'}">${isActive ? 'ğŸŸ¢' : 'ğŸ”´'}</span>
              ${lastPost}
            </td>
            <td>
              <select onchange="updateFeedChannel('${feed.url}', this.value)" style="font-size: 12px;">
                <option value="">No Channel</option>
                ${channels.map(ch => 
                  `<option value="${ch.id}" ${feedMappings[feed.url] === ch.id ? 'selected' : ''}>${ch.name || ch.id}</option>`
                ).join('')}
              </select>
            </td>
            <td>
              <select onchange="updateFeedGroup('${feed.url}', this.value)" style="font-size: 12px;">
                <option value="">No Group</option>
                ${Object.keys(groups).map(g => 
                  `<option value="${g}" ${getGroup(feed) === g ? 'selected' : ''}>${g}</option>`
                ).join('')}
              </select>
            </td>
            <td>
              <a href="${pageUrl}" target="_blank" class="btn btn-outline" style="font-size: 12px;">ğŸ”— Visit</a>
            </td>
            <td>
              <button onclick="removeFeed('${feed.url}')" class="btn btn-danger" style="font-size: 12px;">ğŸ—‘ï¸</button>
            </td>
          </tr>
        `;
      });

      html += '</tbody></table>';
      container.innerHTML = html;
    }

    // Render grouped feed list
    function renderGroupedFeeds(feedList) {
      const container = document.getElementById('feeds-container');
      
      // Group feeds
      const groupedFeeds = {};
      feedList.forEach(feed => {
        const group = getGroup(feed) || 'Ungrouped';
        if (!groupedFeeds[group]) groupedFeeds[group] = [];
        groupedFeeds[group].push(feed);
      });

      let html = '';
      Object.entries(groupedFeeds).forEach(([groupName, groupFeeds]) => {
        html += `
          <div class="card mb-20">
            <div class="card-header flex-between">
              <div class="card-title">ğŸ“ ${groupName} (${groupFeeds.length})</div>
              <div>
                <button onclick="toggleGroup('${groupName}')" class="btn btn-outline">ğŸ‘ï¸ Toggle</button>
                ${groupName !== 'Ungrouped' ? `<button onclick="removeGroup('${groupName}')" class="btn btn-danger">ğŸ—‘ï¸</button>` : ''}
              </div>
            </div>
            <div class="group-feeds" id="group-${groupName}">
              <table class="feeds-table">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Last Post</th>
                    <th>Channel</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody>
                  ${groupFeeds.map(feed => `
                    <tr>
                      <td>${getTitle(feed)}</td>
                      <td>${formatDate(getLastPost(feed))}</td>
                      <td>${getChannelName(feed)}</td>
                      <td>
                        <button onclick="removeFeed('${feed.url}')" class="btn btn-danger" style="font-size: 12px;">ğŸ—‘ï¸</button>
                      </td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
            </div>
          </div>
        `;
      });

      container.innerHTML = html;
    }

    // Render channels list
    function renderChannels() {
      const container = document.getElementById('channels-list');
      
      if (channels.length === 0) {
        container.innerHTML = '<div class="loading">No channels configured</div>';
        return;
      }

      let html = '';
      channels.forEach(channel => {
        const feedCount = Object.values(feedMappings).filter(id => id === channel.id).length;
        
        html += `
          <div class="card mb-10">
            <div class="flex-between">
              <div>
                <strong>${channel.name || channel.id}</strong>
                <span class="badge bg-secondary">${channel.type || 'text'}</span>
                <small class="text-muted">ID: ${channel.id}</small>
                <span class="badge bg-info">${feedCount} feeds</span>
              </div>
              <button onclick="removeChannel('${channel.id}')" class="btn btn-danger">ğŸ—‘ï¸ Remove</button>
            </div>
          </div>
        `;
      });

      container.innerHTML = html;
    }

    // Helper functions
    function getTitle(feed) {
      return feedMetadata[feed.url]?.title || feed.title || 'Unknown Feed';
    }

    function getLastPost(feed) {
      return feedMetadata[feed.url]?.last_post || feed.lastPost || null;
    }

    function getPageUrl(feed) {
      return feedMetadata[feed.url]?.page_url || feed.pageUrl || feed.url;
    }

    function getGroup(feed) {
      for (const [groupName, feedList] of Object.entries(groups)) {
        if (Array.isArray(feedList) && feedList.includes(feed.url)) {
          return groupName;
        }
      }
      return null;
    }

    function getChannelName(feed) {
      const channelId = feedMappings[feed.url];
      if (!channelId) return 'None';
      const channel = channels.find(ch => ch.id === channelId);
      return channel ? (channel.name || channel.id) : 'Unknown';
    }

    function isActiveFeed(feed) {
      const lastPost = getLastPost(feed);
      if (!lastPost) return false;
      const daysSince = (Date.now() - new Date(lastPost)) / (1000 * 60 * 60 * 24);
      return daysSince <= 7;
    }

    function formatDate(dateStr) {
      if (!dateStr) return 'Never';
      const date = new Date(dateStr);
      const now = new Date();
      const diffHours = Math.floor((now - date) / (1000 * 60 * 60));
      
      if (diffHours < 24) {
        return diffHours < 1 ? 'Just now' : `${diffHours}h ago`;
      } else {
        const diffDays = Math.floor(diffHours / 24);
        return `${diffDays}d ago`;
      }
    }

    // View/Sort/Filter controls
    window.setView = function(view) {
      currentView = view;
      document.getElementById('view-flat').classList.toggle('active', view === 'flat');
      document.getElementById('view-grouped').classList.toggle('active', view === 'grouped');
      renderFeeds();
    };

    window.setSort = function(sort) {
      currentSort = sort;
      document.querySelectorAll('[id^="sort-"]').forEach(btn => {
        btn.classList.remove('active');
      });
      document.getElementById(`sort-${sort}`).classList.add('active');
      renderFeeds();
    };

    window.setFilter = function(filter) {
      currentFilter = filter;
      document.querySelectorAll('[id^="filter-"]').forEach(btn => {
        btn.classList.remove('active');
      });
      document.getElementById(`filter-${filter}`).classList.add('active');
      renderFeeds();
    };

    // Feed management
    window.addFeed = async function() {
      const input = document.getElementById('new-feed-url');
      const url = input.value.trim();
      
      if (!url) {
        showAlert('Please enter a feed URL', 'warning');
        return;
      }

      try {
        await HanuAPI.addFeed(url);
        input.value = '';
        await loadAllData();
        showAlert('Feed added successfully! ğŸ‰', 'success');
      } catch (error) {
        showAlert('Failed to add feed: ' + error.message, 'danger');
      }
    };

    window.removeFeed = async function(feedUrl) {
      if (!confirm('Are you sure you want to remove this feed?')) return;

      try {
        await HanuAPI.removeFeed(feedUrl);
        await loadAllData();
        showAlert('Feed removed successfully', 'success');
      } catch (error) {
        showAlert('Failed to remove feed: ' + error.message, 'danger');
      }
    };

    window.updateFeedChannel = async function(feedUrl, channelId) {
      try {
        await HanuAPI.updateFeedMapping(feedUrl, channelId);
        feedMappings[feedUrl] = channelId;
        showAlert('Channel mapping updated! âœ…', 'success');
      } catch (error) {
        showAlert('Failed to update mapping: ' + error.message, 'danger');
      }
    };

    window.updateFeedGroup = async function(feedUrl, groupName) {
      try {
        await HanuAPI.updateFeedGroup(feedUrl, groupName);
        await loadAllData(); // Reload to update groups
        showAlert('Group updated! âœ…', 'success');
      } catch (error) {
        showAlert('Failed to update group: ' + error.message, 'danger');
      }
    };

    // Group management
    window.addGroup = async function() {
      const input = document.getElementById('new-group-name');
      const name = input.value.trim();
      
      if (!name) {
        showAlert('Please enter a group name', 'warning');
        return;
      }

      try {
        await HanuAPI.addGroup(name);
        input.value = '';
        await loadAllData();
        showAlert('Group created successfully! ğŸ“', 'success');
      } catch (error) {
        showAlert('Failed to create group: ' + error.message, 'danger');
      }
    };

    window.removeGroup = async function(groupName) {
      if (!confirm(`Remove group "${groupName}"? Feeds will become ungrouped.`)) return;

      try {
        await HanuAPI.removeGroup(groupName);
        await loadAllData();
        showAlert('Group removed successfully', 'success');
      } catch (error) {
        showAlert('Failed to remove group: ' + error.message, 'danger');
      }
    };

    window.toggleGroup = function(groupName) {
      const groupElement = document.getElementById(`group-${groupName}`);
      if (groupElement) {
        groupElement.style.display = groupElement.style.display === 'none' ? 'block' : 'none';
      }
    };

    // Channel management
    window.addChannel = async function() {
      const idInput = document.getElementById('new-channel-id');
      const nameInput = document.getElementById('new-channel-name');
      const typeSelect = document.getElementById('new-channel-type');
      
      const channelId = idInput.value.trim();
      const name = nameInput.value.trim();
      const type = typeSelect.value;
      
      if (!channelId) {
        showAlert('Please enter a channel ID', 'warning');
        return;
      }

      try {
        await HanuAPI.addChannel(channelId, name, type);
        idInput.value = '';
        nameInput.value = '';
        typeSelect.value = 'text';
        await loadAllData();
        showAlert('Channel added successfully! ğŸ’¬', 'success');
      } catch (error) {
        showAlert('Failed to add channel: ' + error.message, 'danger');
      }
    };

    window.removeChannel = async function(channelId) {
      const feedCount = Object.values(feedMappings).filter(id => id === channelId).length;
      if (feedCount > 0 && !confirm(`This channel has ${feedCount} mapped feeds. Remove anyway?`)) return;

      try {
        await HanuAPI.removeChannel(channelId);
        await loadAllData();
        showAlert('Channel removed successfully', 'success');
      } catch (error) {
        showAlert('Failed to remove channel: ' + error.message, 'danger');
      }
    };

    // Bot controls
    window.runBot = async function() {
      const button = document.getElementById('run-bot-btn');
      const output = document.getElementById('job-output');
      
      button.disabled = true;
      button.innerHTML = '<span class="loading-spinner"></span> Running...';
      output.classList.remove('hidden');
      output.textContent = 'â³ Starting bot job...';

      try {
        const result = await HanuAPI.runBot();
        output.textContent = `âœ… Bot job completed!\n\n${result}`;
        
        // Refresh data after successful run
        setTimeout(async () => {
          await loadAllData();
        }, 2000);
        
      } catch (error) {
        output.textContent = `âŒ Bot job failed: ${error.message}`;
      } finally {
        button.disabled = false;
        button.innerHTML = 'ğŸš€ Run Bot Now';
      }
    };

    window.clearCache = async function() {
      try {
        await HanuAPI.clearCache();
        showAlert('Cache cleared successfully! ğŸ—‘ï¸', 'success');
      } catch (error) {
        showAlert('Failed to clear cache: ' + error.message, 'danger');
      }
    };

    window.refreshData = async function() {
      try {
        await loadAllData();
        showAlert('Data refreshed successfully! ğŸ”„', 'success');
      } catch (error) {
        showAlert('Failed to refresh data: ' + error.message, 'danger');
      }
    };

    window.exportData = function() {
      const data = {
        feeds,
        channels, 
        groups,
        feedMappings,
        feedMetadata,
        exportedAt: new Date().toISOString()
      };

      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `hanu-dashboard-export-${new Date().toISOString().slice(0, 10)}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showAlert('Data exported successfully! ğŸ“¥', 'success');
    };

    // Alert helper
    function showAlert(message, type = 'info') {
      const alertDiv = document.createElement('div');
      alertDiv.className = `alert alert-${type} fade-in`;
      alertDiv.style.position = 'fixed';
      alertDiv.style.top = '20px';
      alertDiv.style.right = '20px';
      alertDiv.style.zIndex = '10000';
      alertDiv.style.minWidth = '300px';
      alertDiv.textContent = message;
      
      document.body.appendChild(alertDiv);
      
      setTimeout(() => {
        alertDiv.remove();
      }, 5000);
    }
  </script>
</body>
</html>
